function callGateMethod(gate, method, ...)
    -- Calls a method on a remote gate via modem
    local methods = {
        energy = isVersion1122 and "getEnergyStored" or "energyAvailable",
        address = isVersion1122 and "getLocalAddress" or "localAddress",
        state = isVersion1122 and "getStargateState" or "stargateState",
        iris = isVersion1122 and "getIrisState" or "irisState",
        dial = isVersion1122 and "dialAddress" or "dial",
        disconnect = isVersion1122 and "close" or "disconnect",
        openIris = "openIris",
        closeIris = "closeIris"
    }
    local actualMethod = methods[method] or method
    return modem.callRemote(gate, actualMethod, ...)
end

function findGates()
    stargates = {}
    local names = modem.getNamesRemote() or {}
    for _, name in pairs(names) do
        if modem.getTypeRemote(name) == "stargate" and #stargates < config.MAX_GATES then
            table.insert(stargates, name)
            if not config.gatePositions[name] then
                config.gatePositions[name] = {gateX = 0, gateY = 0, gateZ = 0, compX = 0, compY = 0, compZ = 0}
            end
        end
    end
    if #stargates > 0 then
        gateName = stargates[1]
        logAction("Found " .. #stargates .. " Stargates. Selected: " .. (config.gateNames[gateName] or gateName))
        return true
    end
    logAction("No Stargates detected")
    return false
end

function calculateGateDistance()
    if not gateName or not config.gatePositions[gateName] then
        return "Unknown"
    end
    local pos = config.gatePositions[gateName]
    local dx = pos.gateX - pos.compX
    local dy = pos.gateY - pos.compY
    local dz = pos.gateZ - pos.compZ
    local distance = math.floor(math.sqrt(dx^2 + dy^2 + dz^2) + 0.5)
    return tostring(distance) .. " blocks"
end

local gateCache = {}
function syncWithGate()
    -- Syncs gate data with caching to reduce modem calls
    if not gateName then 
        logAction("Sync failed: No gate selected")
        gateStatus = "Disconnected"
        return false
    end
    local success, result = pcall(function()
        gateCache[gateName] = gateCache[gateName] or {}
        local cache = gateCache[gateName]
        local now = os.clock()
        if not cache.lastSync or (now - cache.lastSync >= config.SYNC_INTERVAL) then
            cache.localAddress = callGateMethod(gateName, "address") or "Unknown"
            cache.gateStatus = callGateMethod(gateName, "state") or "Disconnected"
            cache.irisState = callGateMethod(gateName, "iris") == "Open"
            cache.remoteAddr = callGateMethod(gateName, "remoteAddress") or "none"
            cache.fuelGauge = callGateMethod(gateName, "energy") or 0
            cache.lastSync = now
        end
        localAddress = cache.localAddress
        gateStatus = cache.gateStatus
        irisState = cache.irisState
        local remoteAddr = cache.remoteAddr
        fuelGauge = cache.fuelGauge
        maxFuel = isVersion1122 and config.FUEL_MAX_1122 or config.FUEL_MAX_1710
        table.insert(fuelHistory, 1, fuelGauge)
        if #fuelHistory > 50 then table.remove(fuelHistory, 51) end

        if gateStatus == "Connected" then
            if lastDialedAddress then
                dialAddress = lastDialedAddress
                incomingAddress = "none"
                for _, gate in ipairs(stargates) do
                    if gate ~= gateName then
                        local otherAddr = callGateMethod(gate, "address") or "Unknown"
                        if otherAddr == remoteAddr then
                            dialAddress = "none"
                            incomingAddress = remoteAddr
                            logAction("Detected incoming from network gate: " .. remoteAddr)
                            break
                        end
                    end
                end
            else
                dialAddress = "none"
                incomingAddress = remoteAddr
                logAction("No lastDialedAddress, assuming incoming: " .. remoteAddr)
                if config.BLOCKED_ADDRESSES[incomingAddress] then
                    callGateMethod(gateName, "disconnect")
                    logAction("Blocked incoming call from: " .. incomingAddress)
                    secureStatus = "blocked"
                elseif addressBook[incomingAddress] and not addressBook[incomingAddress].isTrusted then
                    callGateMethod(gateName, "closeIris")
                    logAction("Auto-closed iris for untrusted incoming: " .. remoteAddr)
                end
            end
        else
            dialAddress = "none"
            incomingAddress = "none"
            lastDialedAddress = nil
            secureStatus = "allclear"
        end
    end)
    if not success then
        logAction("Sync error: " .. tostring(result))
        gateStatus = "Error"
        return false
    end
    return true
end

function toggleIris()
    if not gateName then 
        logAction("Iris toggle failed: No gate selected")
        return false
    end
    local success, result = pcall(function()
        if irisState then
            callGateMethod(gateName, "closeIris")
            logAction("Iris closed on " .. gateName)
        else
            callGateMethod(gateName, "openIris")
            logAction("Iris opened on " .. gateName)
        end
    end)
    if not success then
        logAction("Iris toggle error: " .. tostring(result))
        return false
    end
    gateCache[gateName] = nil -- Invalidate cache
    return syncWithGate()
end

function disconnectGate()
    if not gateName or config.LOCKDOWN_MODE then 
        logAction("Disconnect failed: " .. (not gateName and "No gate selected" or "Lockdown active"))
        return false
    end
    local success, result = pcall(function()
        callGateMethod(gateName, "disconnect")
        logAction("Gate disconnected on " .. gateName)
    end)
    if not success then
        logAction("Disconnect error: " .. tostring(result))
        return false
    end
    gateCache[gateName] = nil -- Invalidate cache
    return syncWithGate()
end

function emergencyShutdown()
    if not gateName then 
        logAction("Emergency shutdown failed: No gate selected")
        return false
    end
    local success, result = pcall(function()
        callGateMethod(gateName, "disconnect")
        if config.EMERGENCY_IRIS_CLOSE then
            callGateMethod(gateName, "closeIris")
            logAction("Emergency: Iris closed on " .. gateName)
        end
        config.LOCKDOWN_MODE = true
        logAction("Emergency shutdown executed on " .. gateName .. ", lockdown enabled")
    end)
    if not success then
        logAction("Emergency shutdown error: " .. tostring(result))
        return false
    end
    gateCache[gateName] = nil -- Invalidate cache
    return syncWithGate()
end

function toggleLockdown()
    if not gateName then 
        logAction("Lockdown toggle failed: No gate selected")
        return false
    end
    config.LOCKDOWN_MODE = not config.LOCKDOWN_MODE
    local success, result = pcall(function()
        if config.LOCKDOWN_MODE then
            callGateMethod(gateName, "disconnect")
            if config.EMERGENCY_IRIS_CLOSE then
                callGateMethod(gateName, "closeIris")
            end
            logAction("Lockdown enabled: Gate disconnected and iris closed on " .. gateName)
        else
            logAction("Lockdown disabled on " .. gateName)
        end
    end)
    if not success then
        logAction("Lockdown toggle error: " .. tostring(result))
        return false
    end
    gateCache[gateName] = nil -- Invalidate cache
    return syncWithGate()
end

function isValidAddress(address)
    return address and #address >= (config.ADDRESS_MIN_LENGTH or 6) and #address <= (config.ADDRESS_MAX_LENGTH or 9) and address:match(config.ADDRESS_PATTERN or "^[A-Z0-9]+$")
end

function dialGate(address)
    if not gateName then 
        logAction("Dialing failed: No gate selected")
        return false 
    end
    if config.LOCKDOWN_MODE then 
        logAction("Dialing failed: Lockdown active")
        return false 
    end
    if not isValidAddress(address) then
        logAction("Invalid address attempted: " .. (address or "nil"))
        return false
    end
    local success, result = pcall(function()
        callGateMethod(gateName, "dial", address)
    end)
    if not success then
        logAction("Dialing error: " .. tostring(result))
        return false
    end
    lastDialedAddress = address
    table.insert(recentAddresses, 1, address)
    if #recentAddresses > (config.MAX_RECENT_ADDRESSES or 10) then table.remove(recentAddresses, (config.MAX_RECENT_ADDRESSES or 10) + 1) end
    logAction("Dialed address: " .. address .. " on " .. (gateName or "Unknown"))
    local startTime = os.clock()
    local maxWait = config.DIAL_WAIT or 0.5
    while os.clock() - startTime < maxWait do
        if syncWithGate() and gateStatus == "Connected" then
            local dialTime = os.clock() - startTime
            logAction("Gate connected in " .. string.format("%.2f", dialTime) .. " seconds")
            return true
        end
        sleep(0.1)
    end
    syncWithGate()
    if gateStatus == "Connected" then
        local dialTime = os.clock() - startTime
        logAction("Gate connected in " .. string.format("%.2f", dialTime) .. " seconds")
        return true
    else
        logAction("Gate failed to connect within " .. maxWait .. " seconds")
        return false
    end
end

function preDialAddress()
    if not config.PRE_DIAL_ADDRESS or config.AUTO_DIAL_ADDRESS or not gateName then return false end
    local firstAddress = nil
    for _, data in pairs(addressBook) do
        if data.code and isValidAddress(data.code) then
            firstAddress = data.code
            break
        end
    end
    if firstAddress then
        logAction("Pre-dialing address: " .. firstAddress)
        local success, result = pcall(function()
            callGateMethod(gateName, "dial", firstAddress)
        end)
        if not success then
            logAction("Pre-dial error: " .. tostring(result))
            return false
        end
        gateCache[gateName] = nil -- Invalidate cache
        return true
    end
    return false
end